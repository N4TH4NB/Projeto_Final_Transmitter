#include "gps.h"
#include "config.h"

NAV_POSLLH navPosllh;

const unsigned char UBX_HEADER[] = { 0xB5, 0x62 };
const char UBLOX_INIT[] PROGMEM = {
  //Configurações de protocolo GPS
  // Disable NMEA
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24,  // GxGGA off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x2B,  // GxGLL off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x32,  // GxGSA off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x39,  // GxGSV off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x40,  // GxRMC off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x47,  // GxVTG off
  // Disable UBX
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xDC,  //NAV-PVT off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0xB9,  //NAV-POSLLH off
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xC0,  //NAV-STATUS off
  // Enable UBX
  0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x13, 0xBE,  //NAV-POSLLH on
  // Rate
  0xB5, 0x62, 0x06, 0x08, 0x06, 0x00, 0xE8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0x39,  //(1Hz)
};

const char UBLOX_OFF[] PROGMEM = {
  // Configurações para desligar GPS
  0xB5, 0x62, 0x02, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x4D, 0x3B,  //Desligado até mudança em RX
};

void configuraGPS(const char *UBLOX) {
  for (size_t i = 0; i < sizeof(UBLOX); i++) {
    Serial2.write(pgm_read_byte(UBLOX + i));
    delay(5);
  }
}

void calcChecksum(unsigned char *CK) {
  memset(CK, 0, 2);
  for (int i = 0; i < (int)sizeof(NAV_POSLLH); i++) {
    CK[0] += ((unsigned char *)(&navPosllh))[i];
    CK[1] += CK[0];
  }
}

bool processGPS() {
  static int fpos = 0;
  static unsigned char checksum[2];
  const int payloadSize = sizeof(NAV_POSLLH);

  while (Serial2.available()) {
    byte c = Serial2.read();
    if (fpos < 2) {
      if (c == UBX_HEADER[fpos])
        fpos++;
      else
        fpos = 0;
    } else {
      if ((fpos - 2) < payloadSize)
        ((unsigned char *)(&navPosllh))[fpos - 2] = c;

      fpos++;

      if (fpos == (payloadSize + 2)) {
        calcChecksum(checksum);
      } else if (fpos == (payloadSize + 3)) {
        if (c != checksum[0])
          fpos = 0;
      } else if (fpos == (payloadSize + 4)) {
        fpos = 0;
        if (c == checksum[1]) {
          return true;
        }
      } else if (fpos > (payloadSize + 4)) {
        fpos = 0;
      }
    }
  }
  return false;
}
